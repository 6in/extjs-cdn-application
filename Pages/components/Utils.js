var indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

var getCharCode, init_UTF8_map;

init_UTF8_map = function (scope) {
    var nonSurrogatePair, rangeArray, singleCharMap, surrogatePair;
    nonSurrogatePair = [[0x00A1, 0], [0x00A4, 0], [0x00AA, 0], [0x00C6, 0], [0x00D0, 0], [0x00E6, 0], [0x00F0, 0], [0x00FC, 0], [0x00FE, 0], [0x0101, 0], [0x0111, 0], [0x0113, 0], [0x011B, 0], [0x012B, 0], [0x0138, 0], [0x0144, 0], [0x014D, 0], [0x016B, 0], [0x01CE, 0], [0x01D0, 0], [0x01D2, 0], [0x01D4, 0], [0x01D6, 0], [0x01D8, 0], [0x01DA, 0], [0x01DC, 0], [0x0251, 0], [0x0261, 0], [0x02C4, 0], [0x02C7, 0], [0x02CD, 0], [0x02D0, 0], [0x02DD, 0], [0x02DF, 0], [0x0401, 0], [0x0451, 0], [0x2010, 0], [0x2030, 0], [0x2035, 0], [0x203B, 0], [0x203E, 0], [0x2074, 0], [0x207F, 0], [0x20AC, 0], [0x2103, 0], [0x2105, 0], [0x2109, 0], [0x2113, 0], [0x2116, 0], [0x2126, 0], [0x212B, 0], [0x21D2, 0], [0x21D4, 0], [0x21E7, 0], [0x2200, 0], [0x220B, 0], [0x220F, 0], [0x2211, 0], [0x2215, 0], [0x221A, 0], [0x2223, 0], [0x2225, 0], [0x222E, 0], [0x2248, 0], [0x224C, 0], [0x2252, 0], [0x2295, 0], [0x2299, 0], [0x22A5, 0], [0x22BF, 0], [0x2312, 0], [0x25CB, 0], [0x25EF, 0], [0x2609, 0], [0x261C, 0], [0x261E, 0], [0x2640, 0], [0x2642, 0], [0x266F, 0], [0x273D, 0], [0x3000, 0], [0xFFFD, 0], [0x00A7, 0x00A8], [0x00AD, 0x00AE], [0x00B0, 0x00B4], [0x00B6, 0x00BA], [0x00BC, 0x00BF], [0x00D7, 0x00D8], [0x00DE, 0x00E1], [0x00E8, 0x00EA], [0x00EC, 0x00ED], [0x00F2, 0x00F3], [0x00F7, 0x00FA], [0x0126, 0x0127], [0x0131, 0x0133], [0x013F, 0x0142], [0x0148, 0x014B], [0x0152, 0x0153], [0x0166, 0x0167], [0x02C9, 0x02CB], [0x02D8, 0x02DB], [0x0300, 0x036F], [0x0391, 0x03A9], [0x03B1, 0x03C1], [0x03C3, 0x03C9], [0x0410, 0x044F], [0x1100, 0x115F], [0x2013, 0x2016], [0x2018, 0x2019], [0x201C, 0x201D], [0x2020, 0x2022], [0x2024, 0x2027], [0x2032, 0x2033], [0x2081, 0x2084], [0x2121, 0x2122], [0x2153, 0x2154], [0x215B, 0x215E], [0x2160, 0x216B], [0x2170, 0x2179], [0x2190, 0x2199], [0x21B8, 0x21B9], [0x2202, 0x2203], [0x2207, 0x2208], [0x221D, 0x2220], [0x2227, 0x222C], [0x2234, 0x2237], [0x223C, 0x223D], [0x2260, 0x2261], [0x2264, 0x2267], [0x226A, 0x226B], [0x226E, 0x226F], [0x2282, 0x2283], [0x2286, 0x2287], [0x2329, 0x232A], [0x2460, 0x24E9], [0x24EB, 0x254B], [0x2550, 0x2573], [0x2580, 0x258F], [0x2592, 0x2595], [0x25A0, 0x25A1], [0x25A3, 0x25A9], [0x25B2, 0x25B3], [0x25B6, 0x25B7], [0x25BC, 0x25BD], [0x25C0, 0x25C1], [0x25C6, 0x25C8], [0x25CE, 0x25D1], [0x25E2, 0x25E5], [0x2605, 0x2606], [0x260E, 0x260F], [0x2614, 0x2615], [0x2660, 0x2661], [0x2663, 0x2665], [0x2667, 0x266A], [0x266C, 0x266D], [0x2776, 0x277F], [0x2E80, 0x2FFB], [0x3001, 0x303E], [0x3041, 0x33FF], [0x3400, 0x4DB5], [0x4E00, 0x9FBB], [0xA000, 0xA4C6], [0xAC00, 0xD7A3], [0xE000, 0xF8FF], [0xF900, 0xFAD9], [0xFE00, 0xFE0F], [0xFE10, 0xFE19], [0xFE30, 0xFE6B], [0xFF01, 0xFF60], [0xFFE0, 0xFFE6]];
    surrogatePair = [[0x20000, 0x2a6d6], [0x2a6d7, 0x2f7ff], [0x2f800, 0x2fa1d], [0x2fa1e, 0x2fffd], [0x30000, 0x3fffd], [0xe0100, 0xe01ef], [0xf0000, 0xffffd], [0x100000, 0x10fffd]];
    singleCharMap = {};
    rangeArray = [];
    nonSurrogatePair.forEach(function (v) {
        if (v[1] === 0) {
            return singleCharMap[v[0]] = true;
        } else {
            return rangeArray.push(v);
        }
    });
    scope.isWideChar = function (code) {
        var j, len1, rng;
        if (code in singleCharMap) {
            return true;
        }
        for (j = 0, len1 = rangeArray.length; j < len1; j++) {
            rng = rangeArray[j];
            if (rng[0] <= code && code <= rng[1]) {
                return true;
            }
        }
        return false;
    };
    return scope.isSurrogateChar = function (code) {
        var j, len1, rng;
        for (j = 0, len1 = surrogatePair.length; j < len1; j++) {
            rng = surrogatePair[j];
            if (rng[0] <= code && code <= rng[1]) {
                return true;
            }
        }
        return false;
    };
};

getCharCode = function (string, scope) {
    var c, counter, i, l, len, result;
    if (scope == null) {
        scope = window;
    }
    counter = 0;
    i = 0;
    l = string.length;
    result = [];
    while (i < l) {
        c = string.charCodeAt(i);
        len = 1;
        if (0xd800 <= c && c <= 0xd8ff) {
            c = 0x10000 + ((c & 0x3ff) << 10) | (string.charCodeAt(i + 1) & 0x3ff);
            if (scope.isSurrogateChar(c)) {
                len = 2;
            }
            i++;
        } else {
            if (scope.isWideChar(c)) {
                len = 2;
            }
        }
        result.push(len);
        i++;
    }
    return result;
};

// ---
// generated by coffee-script 1.9.2

Ext.define("StringLengh", {
    statics: {
        objScope: null
    },
    constructor: function (config) {
        this.initConfig(config);
        if (StringLengh.objScope == null) {
            StringLengh.objScope = {}
            init_UTF8_map(StringLengh.objScope)
        }
        return this;
    },
    getStringLength(text) {
        return getCharCode(text, StringLengh.objScope).reduce((x, y) => x + y)
    }
})

Ext.define("KeisenUtil.Base", {
    config: {
        controller: null
    },
    constructor: function (config) {
        this.initConfig(config);
        return this;
    },
    textToDataImpl: function (text, cutLines, lastLine) {
        var lastIndes, lastIndex, me, rows;
        if (lastLine == null) {
            lastLine = false;
        }
        me = this;
        lastIndex = -1;
        if (lastLine) {
            lastIndes = -2;
        }
        rows = text.split(/\r?\n/).filter(function (line, lineNo) {
            return !(indexOf.call(cutLines, lineNo) >= 0);
        }).slice(0).map(function (line) {
            return line.split(/\|/).map(function (col) {
                return me.escapeMarkdownToData(col).trim();
            }).slice(1, -1);
        }).slice(0, +lastIndex + 1 || 9e9);
        return rows;
    },
    escapeDataToMarkdown: function (text) {
        return text.replace(/\r?\n/g, "<br>").replace(/\|/g, "｜").replace(/\\/g, "\\\\");
    },
    escapeMarkdownToData: function (text) {
        return text.replace(/<br>/gi, "\n").replace(/｜/g, "|").replace(/\\\\/g, "\\");
    },
    trimRows(rows) {
        const cols = rows[0]
        let colsLength = cols.length

        const newRows = []
        let isSkip = false
        rows.forEach(row => {
            if (isSkip) {
                return
            }
            let newRow = row.slice(0, colsLength).map(col => {
                return col === null ? '' : col
            })
            let content = []
            for (let i = 0; i < colsLength; i++) {
                content.push(row[i] ? `${row[i]}`.trim() : '')
            }
            if (content.join("").trim() === "") {
                isSkip = true
                return
            }
            console.log(content)
            newRows.push(newRow)
        })
        return newRows
    }

});

Ext.define("KeisenUtil.Keisen", {
    extend: "KeisenUtil.Base",
    dataToText: function (data) {
        var me = this
        var e, ret;
        ret = {
            text: "",
            error: ""
        };
        try {
            data.rows = me.trimRows(data.rows)
            data.rows = data.rows.map(function (row) {
                return row.map(function (col) {
                    return col.replace(/\r?\n/g, " ");
                });
            });
            ret.text = StrUtil.makeKeisenImpl(data.cols, data.rows);
        } catch (_error) {
            e = _error;
            console.log(e);
            ret.error = e.toString();
        }
        return ret;
    },
    textToData: function (text) {
        var ret;
        ret = {
            rows: []
        };
        return this.textToDataImpl(text, [0, 2], true);
    }
});

Ext.define("KeisenUtil.Redmine", {
    extend: "KeisenUtil.Base",
    dataToText: function (data) {
        var cols, e, me, result, ret, rows;
        me = this;
        ret = {
            text: "",
            error: ""
        };
        data.rows = me.trimRows(data.rows)
        cols = data.cols;
        rows = data.rows;
        try {
            result = [];
            result.push("|" + cols.map(function (col) {
                return "_. " + col;
            }).join(" |") + " |");
            rows.map(function (row) {
                row = row.map(function (v) {
                    return me.escapeDataToMarkdown(v);
                });
                return result.push("| " + row.join(" | ") + " |");
            });
            ret.text = result.join("\n");
        } catch (_error) {
            e = _error;
            console.log(e);
            ret.error = e.toString();
        }
        return ret;
    },
    textToData: function (text) {
        var head, ret, rows;
        ret = {
            rows: []
        };
        rows = this.textToDataImpl(text, [], false);
        head = rows[0];
        head.forEach(function (col, idx) {
            return head[idx] = col.replace(/_\./, "").trim();
        });
        return rows;
    }
});

Ext.define("KeisenUtil.Html", {
    extend: "KeisenUtil.Base",
    dataToText: function (data) {
        var alignRight, cols, e, me, result, ret, rows;
        me = this;
        ret = {
            text: "",
            error: ""
        };
        data.rows = me.trimRows(data.rows)
        cols = data.cols;
        rows = data.rows;
        try {
            alignRight = rows[0].map(function (col) {
                return Ext.isNumeric(("" + col).replace(/,/g, ""));
            }).map(function (isNum) {
                if (isNum) {
                    return ":";
                } else {
                    return "";
                }
            });
            result = ["<table border=1>"];
            result.push("  <tr><th>" + cols.join("</th><th>") + "</th></tr>");
            rows.map(function (row) {
                row = row.map(function (v) {
                    return me.escapeDataToMarkdown(v);
                });
                return result.push("  <tr><td>" + row.join("</td><td>") + "</td></tr>");
            });
            result.push("</table>");
            ret.text = result.join("\n");
        } catch (_error) {
            e = _error;
            console.log(e);
            ret.error = e.toString();
        }
        return ret;
    },
    textToData: function (text) {
        var ret;
        ret = {
            rows: []
        };
        return this.textToDataImpl(text, [1], false);
    }
});

Ext.define("KeisenUtil.Gitlab", {
    extend: "KeisenUtil.Base",
    dataToText: function (data) {
        var alignRight, cols, e, me, result, ret, rows;
        me = this;
        ret = {
            text: "",
            error: ""
        };
        data.rows = me.trimRows(data.rows)
        cols = data.cols;
        rows = data.rows;
        try {
            alignRight = rows[0].map(function (col) {
                return Ext.isNumeric(("" + col).replace(/,/g, ""));
            }).map(function (isNum) {
                if (isNum) {
                    return ":";
                } else {
                    return "";
                }
            });
            result = [];
            result.push("| " + cols.join(" | ") + " |");
            result.push("| " + cols.map(function (col, idx) {
                return "----" + alignRight[idx];
            }).join(" | ") + " |");
            rows.map(function (row) {
                row = row.map(function (v) {
                    return me.escapeDataToMarkdown(v);
                });
                return result.push("| " + row.join(" | ") + " |");
            });
            ret.text = result.join("\n");
        } catch (_error) {
            e = _error;
            console.log(e);
            ret.error = e.toString();
        }
        return ret;
    },
    textToData: function (text) {
        var ret;
        ret = {
            rows: []
        };
        return this.textToDataImpl(text, [1], false);
    }
});

Ext.define("StrUtil", {
    statics: {
        regNum: /^[+-]?\d[0-9,]*(\.\d+)?$/,
        multiCaseConvert: function (obj, attributeName) {
            var columnName, columnValue, me;
            me = this;
            columnName = me.caseConvert(attributeName);
            columnValue = me.caseConvert(obj[attributeName]);
            obj[columnName.SNAKE_CASE] = columnValue.SNAKE_CASE;
            obj[columnName.snake_case] = columnValue.snake_case;
            obj[columnName.CamelCase] = columnValue.CamelCase;
            return obj[columnName.camelCase] = columnValue.camelCase;
        },
        caseConvert: function (snakecase) {
            var CamelCase, me, ret;
            me = this;
            CamelCase = me.toCamelCase(snakecase);
            return ret = {
                SNAKE_CASE: snakecase.toUpperCase(),
                snake_case: snakecase.toLowerCase(),
                CamelCase: CamelCase,
                camelCase: CamelCase[0].toLowerCase() + CamelCase.slice(1),
                SHORT: me.toShortName(snakecase)
            };
        },
        toCamelCase: function (snakecase) {
            snakecase = snakecase.replace(/_+/g, "_");
            return snakecase.toLowerCase().split("_").map(function (token) {
                return token[0].toUpperCase() + token.slice(1);
            }).join("");
        },
        toShortName: function (snakecase) {
            snakecase = snakecase.replace(/_+/g, "_");
            return snakecase.toLowerCase().split("_").map(function (token) {
                return token[0].toUpperCase();
            }).join("");
        },
        expandTabSpace: function (text, tabWidth) {
            var amari, ch, cur, j, k, len1, ref, result, x;
            if (text.indexOf("\t") === -1) {
                return text;
            }
            if (!tabWidth) {
                tabWidth = 4;
            }
            result = [];
            cur = 0;
            for (j = 0, len1 = text.length; j < len1; j++) {
                ch = text[j];
                if (ch === "\t") {
                    amari = tabWidth - cur % tabWidth;
                    for (x = k = 0, ref = amari - 1; 0 <= ref ? k <= ref : k >= ref; x = 0 <= ref ? ++k : --k) {
                        result.push(" ");
                        cur += 1;
                    }
                } else {
                    result.push(ch);
                    cur += 1;
                }
            }
            return result.join("");
        },
        expandAllTextTabSpace: function (lines, tabWidth, indent) {
            var me;
            if (indent == null) {
                indent = "";
            }
            me = this;
            return lines.split(/\r?\n/).map(function (line) {
                return indent + me.expandTabSpace(line, tabWidth);
            }).join("\n");
        },
        tabFormatImpl: function (line, reTabSpace, tabWidth) {
            var amari, delta, i, ret, spaces, tabCnt, tabInfo, tabSpaceIndex;
            tabSpaceIndex = this.expandTabSpace(line, tabWidth).replace(/[\u0100-\uffff]/g, 11).indexOf("/*TAB=>");
            if (tabSpaceIndex >= 0) {
                ret = line.match(reTabSpace);
                tabInfo = {
                    rep: ret[1],
                    pos: Number(ret[2])
                };
                spaces = " ";
                delta = tabInfo.pos - (tabSpaceIndex + 1);
                if (delta > 0) {
                    tabCnt = Math.floor(delta / tabWidth);
                    amari = delta % tabWidth;
                    if (amari > 0) {
                        tabCnt += 1;
                    }
                    spaces = ((function () {
                        var j, ref, results1;
                        results1 = [];
                        for (i = j = 0, ref = tabCnt; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                            results1.push("");
                        }
                        return results1;
                    })()).join("\t");
                }
                line = line.replace(tabInfo.rep, spaces);
            }
            return line;
        },
        tabFormat: function (lines, tabWidth) {
            var j, len1, line, reTabSpace, result;
            if (tabWidth == null) {
                tabWidth = 4;
            }
            reTabSpace = /(\/\*TAB=>(\d+)\*\/)/;
            result = [];
            for (j = 0, len1 = lines.length; j < len1; j++) {
                line = lines[j];
                line = line.replace(/\/\*TAB\*\//g, "\t");
                while (line.indexOf("/*TAB=>") >= 0) {
                    line = this.tabFormatImpl(line, reTabSpace, tabWidth);
                }
                result.push(line);
            }
            return result;
        },
        getLength: function (w) {
            if (w === '') {
                return 0
            }
            return new StringLengh().getStringLength(w)
            // return w.replace(/[ｱ-ﾟｰ ]/g, "-").replace(/[\u0100-\uffff]/g, "--").length;
        },
        repeat: function (c, l) {
            var i, j, ref, ret;
            ret = "";
            for (i = j = 0, ref = l; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                ret += c;
            }
            return ret;
        },
        makeTsv: function (grid, startColPos) {
            var columns, rows, store;
            if (startColPos == null) {
                startColPos = 0;
            }
            columns = grid.columns.slice(startColPos).map(function (column) {
                return column.dataIndex;
            });
            store = grid.store;
            rows = [];
            store.each(function (rec) {
                var data, row;
                data = rec.data;
                row = columns.map(function (column) {
                    return data[column];
                }).join("\t");
                return rows.push(row);
            });
            return [columns.join("\t")].concat(rows).join("\n");
        },
        getRowsFromGrid: function (grid, startColPos) {
            var columns, rows, store;
            if (startColPos == null) {
                startColPos = 0;
            }
            columns = grid.columns.slice(startColPos).map(function (column) {
                return column.dataIndex;
            });
            store = grid.store;
            rows = [columns];
            store.each(function (rec) {
                var data, row;
                data = rec.data;
                row = columns.map(function (column) {
                    return data[column];
                });
                return rows.push(row);
            });
            return rows;
        },
        makeKeisen: function (grid, startColPos) {
            var colWidth, columns, me, rows, store;
            if (startColPos == null) {
                startColPos = 0;
            }
            me = this;
            columns = grid.columns.slice(startColPos).map(function (column) {
                return column.dataIndex;
            });
            store = grid.store;
            rows = [];
            colWidth = [];
            columns.forEach(function (col, idx) {
                return colWidth[idx] = me.getLength(col);
            });
            store.each(function (rec) {
                var data, row;
                data = rec.data;
                row = columns.map(function (column, idx) {
                    var len, str;
                    str = "" + data[column];
                    len = me.getLength(str);
                    if (colWidth[idx] < len) {
                        colWidth[idx] = len;
                    }
                    return str;
                });
                return rows.push(row);
            });
            return this.makeKeisenImpl(cols, rows, startColPos);
        },
        makeKeisenImpl: function (cols, rows, startColPos) {
            var colWidth, header, idx, keisenRows, len, me, results, sep, separator, wrd;
            if (startColPos == null) {
                startColPos = 0;
            }
            me = this;
            colWidth = [];
            cols.forEach(function (col, idx) {
                return colWidth[idx] = me.getLength(col);
            });
            rows.forEach(function (row) {
                return cols.forEach(function (column, idx) {
                    var len, str;
                    str = "" + row[idx];
                    len = me.getLength(str);
                    if (colWidth[idx] < len) {
                        return colWidth[idx] = len;
                    }
                });
            });
            separator = [""];
            for (idx in colWidth) {
                len = colWidth[idx];
                wrd = me.repeat("-", len);
                separator.push(wrd);
            }
            separator.push("");
            sep = separator.join('+');
            header = cols.map(function (column, idx) {
                var spc;
                len = me.getLength(column);
                spc = colWidth[idx] - len;
                return column + me.repeat(" ", spc);
            }).join("|");
            results = [sep, header = "|" + header + "|", sep];
            keisenRows = rows.map(function (row) {
                return "|" + cols.map(function (column, idx) {
                    var spc;
                    len = me.getLength(row[idx]);
                    spc = colWidth[idx] - len;
                    if (StrUtil.isNumeric("" + row[idx])) {
                        return me.repeat(" ", spc) + row[idx];
                    } else {
                        return row[idx] + me.repeat(" ", spc);
                    }
                }).join("|") + "|";
            });
            return results.concat(keisenRows).concat(sep).join("\n");
        },
        isNumeric: function (num) {
            return StrUtil.regNum.test(num);
        }
    }
});


Ext.define("TreeUtil", {
    statics: {
        tabSize: 2,
        keisenSet: {
            normal: {
                line: "+---",
                bar: "|",
                stop: "\\",
                cross: "+",
                space: " ",
                indent: 4
            },
            zenkaku: {
                line: "├─",
                bar: "│",
                cross: "├",
                stop: "└",
                space: "　",
                indent: 2
            },
            zenkakub: {
                line: "┣━",
                bar: "┃",
                cross: "┣",
                stop: "┗",
                space: "　",
                indent: 2
            }
        },
        currentSet: "normal",
        checkIndent: function (line) {
            var level, name, result;
            result = line.split(/(^\s*)/);
            level = 0;
            name = line;
            if (result.length === 3) {
                level = result[1].length;
                name = result[2];
            }
            return [level / TreeUtil.tabSize, name];
        },
        repeat: function (text, count) {
            var buff, i, j, ref;
            buff = [""];
            if (count > 0) {
                for (i = j = 0, ref = count - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                    buff.push(text);
                }
            }
            return buff.join("");
        },
        lineFromToUp: function (buff, row, col) {
            var i, j, keisen, ref, results;
            row = row - 1;
            keisen = TreeUtil.keisenSet[TreeUtil.currentSet];
            results = [];
            for (i = j = ref = row; j >= 0; i = j += -1) {
                if (buff[i][1][col] === keisen.space) {
                    results.push(buff[i][1][col] = keisen.bar);
                } else {
                    break;
                }
            }
            return results;
        }
    }
});

Ext.define("AnyConvert", {
    statics: {
        reg_SNAKE_CASE: /^([A-Z][A-Za-z0-9_]+)$/,
        reg_snake_case: /^([a-z][A-Za-z0-9_]+)$/,
        reg_CamelCase: /^([A-Z][a-zA-Z0-9]+)$/,
        reg_camelCase: /^([a-z][a-zA-Z0-9]+)$/,
        reg_TRAIN_CASE: /^([A-Z][A-Z0-9\-]+)$/,
        reg_train_case: /^([a-z][a-z0-9\-]+)$/,
        reg_UPPERCASE: /^([A-Z0-9]+)$/,
        reg_lowercase: /^([a-z0-9]+)$/
    },
    constructor: function (args) {
        var me, word;
        me = this;
        me.tokens = [];
        me.srcType = "";
        me.srcWord = args.word;
        me.cmnt = args.cmnt;
        word = args.word;
        if (word.match(AnyConvert.reg_SNAKE_CASE)) {
            me.srcType = "SNAKE_CASE";
            me.tokens = word.split(/_+/);
        }
        if (word.match(AnyConvert.reg_snake_case)) {
            me.srcType = "snake_case";
            me.tokens = word.split(/_+/);
        }
        if (word.match(AnyConvert.reg_CamelCase)) {
            me.srcType = "CamelCase";
            me.tokens = me.parseCamelToken(word)
        }
        if (word.match(AnyConvert.reg_camelCase)) {
            me.srcType = "camelCase";
            me.tokens = me.parseCamelToken(word);
        }
        if (word.match(AnyConvert.reg_TRAIN_CASE)) {
            me.srcType = "TRAIN-CASE";
            me.tokens = word.split(/-+/);
        }
        if (word.match(AnyConvert.reg_train_case)) {
            me.srcType = "train-case";
            me.tokens = word.split(/-+/);
        }
        if (word.match(AnyConvert.reg_UPPERCASE)) {
            me.srcType = "UPPERCASE";
            me.tokens = [word];
        }
        if (word.match(AnyConvert.reg_lowercase)) {
            me.srcType = "lowercase";
            me.tokens = [word];
        }
        me.Tokens = me.tokens.map(function (token) {
            return token[0].toUpperCase() + token.slice(1).toLowerCase();
        });
        me.Uppers = me.tokens.map(function (token) {
            return token.toUpperCase();
        });
        me.Lowers = me.tokens.map(function (token) {
            return token.toLowerCase();
        });
    },
    parseCamelToken(word) {
        var words = []
        var tokens = []
        word.split(/([A-Z])/)
            .filter(w => w)
            .forEach(w => {
                if (w.match(/[A-Z]/)) {
                    const ww = words.join("")
                    if (ww) {
                        tokens.push(ww)
                    }
                    words = []
                }
                words.push(w)
            })
        const ww = words.join("")
        if (ww) {
            tokens.push(ww)
        }
        return tokens
    },
    getRow: function () {
        var me;
        me = this;
        return {
            org: me.srcWord,
            type: me.srcType,
            Comment: me.cmnt,
            SNAKE_CASE: me.Tokens.join("_").toUpperCase(),
            snake_case: [me.Lowers[0]].concat(me.Tokens.slice(1)).join("_").toLowerCase(),
            CamelCase: me.Tokens.join(""),
            camelCase: [me.Lowers[0]].concat(me.Tokens.slice(1)).join(""),
            "TRAIN-CASE": me.Uppers.join("-"),
            "train-case": [me.Lowers[0]].concat(me.Lowers.slice(1)).join("-"),
            UPPERCASE: me.srcWord.toUpperCase(),
            lowercase: me.srcWord.toLowerCase(),
            regexp: me.getRegExpPattern()
        };
    },
    getRegExpPattern: function () {
        var me;
        me = this;
        return me.Lowers.map(function (token) {
            return "[" + (token[0].toUpperCase()) + token[0] + "]" + token.slice(1);
        }).join("[-_]*");
    }
});


Ext.define("TranslateUtil", {
    statics: {
        zenkaku2Hankaku(str) {
            return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
                return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
            });
        },
        hankaku2Zenkaku(str) {
            return str.replace(/[A-Za-z0-9]/g, function (s) {
                return String.fromCharCode(s.charCodeAt(0) + 0xFEE0);
            });
        },
        zenkana2Hankana(str) {
            var kanaMap = {
                "ガ": "ｶﾞ", "ギ": "ｷﾞ", "グ": "ｸﾞ", "ゲ": "ｹﾞ", "ゴ": "ｺﾞ",
                "ザ": "ｻﾞ", "ジ": "ｼﾞ", "ズ": "ｽﾞ", "ゼ": "ｾﾞ", "ゾ": "ｿﾞ",
                "ダ": "ﾀﾞ", "ヂ": "ﾁﾞ", "ヅ": "ﾂﾞ", "デ": "ﾃﾞ", "ド": "ﾄﾞ",
                "バ": "ﾊﾞ", "ビ": "ﾋﾞ", "ブ": "ﾌﾞ", "ベ": "ﾍﾞ", "ボ": "ﾎﾞ",
                "パ": "ﾊﾟ", "ピ": "ﾋﾟ", "プ": "ﾌﾟ", "ペ": "ﾍﾟ", "ポ": "ﾎﾟ",
                "ヴ": "ｳﾞ", "ヷ": "ﾜﾞ", "ヺ": "ｦﾞ",
                "ア": "ｱ", "イ": "ｲ", "ウ": "ｳ", "エ": "ｴ", "オ": "ｵ",
                "カ": "ｶ", "キ": "ｷ", "ク": "ｸ", "ケ": "ｹ", "コ": "ｺ",
                "サ": "ｻ", "シ": "ｼ", "ス": "ｽ", "セ": "ｾ", "ソ": "ｿ",
                "タ": "ﾀ", "チ": "ﾁ", "ツ": "ﾂ", "テ": "ﾃ", "ト": "ﾄ",
                "ナ": "ﾅ", "ニ": "ﾆ", "ヌ": "ﾇ", "ネ": "ﾈ", "ノ": "ﾉ",
                "ハ": "ﾊ", "ヒ": "ﾋ", "フ": "ﾌ", "ヘ": "ﾍ", "ホ": "ﾎ",
                "マ": "ﾏ", "ミ": "ﾐ", "ム": "ﾑ", "メ": "ﾒ", "モ": "ﾓ",
                "ヤ": "ﾔ", "ユ": "ﾕ", "ヨ": "ﾖ",
                "ラ": "ﾗ", "リ": "ﾘ", "ル": "ﾙ", "レ": "ﾚ", "ロ": "ﾛ",
                "ワ": "ﾜ", "ヲ": "ｦ", "ン": "ﾝ",
                "ァ": "ｧ", "ィ": "ｨ", "ゥ": "ｩ", "ェ": "ｪ", "ォ": "ｫ",
                "ッ": "ｯ", "ャ": "ｬ", "ュ": "ｭ", "ョ": "ｮ",
                "。": "｡", "、": "､", "ー": "ｰ", "「": "｢", "」": "｣", "・": "･"
            }
            var reg = new RegExp('(' + Object.keys(kanaMap).join('|') + ')', 'g');
            return str
                .replace(reg, function (match) {
                    return kanaMap[match];
                })
                .replace(/゛/g, 'ﾞ')
                .replace(/゜/g, 'ﾟ');
        },
        hankana2Zenkana(str) {
            var kanaMap = {
                'ｶﾞ': 'ガ', 'ｷﾞ': 'ギ', 'ｸﾞ': 'グ', 'ｹﾞ': 'ゲ', 'ｺﾞ': 'ゴ',
                'ｻﾞ': 'ザ', 'ｼﾞ': 'ジ', 'ｽﾞ': 'ズ', 'ｾﾞ': 'ゼ', 'ｿﾞ': 'ゾ',
                'ﾀﾞ': 'ダ', 'ﾁﾞ': 'ヂ', 'ﾂﾞ': 'ヅ', 'ﾃﾞ': 'デ', 'ﾄﾞ': 'ド',
                'ﾊﾞ': 'バ', 'ﾋﾞ': 'ビ', 'ﾌﾞ': 'ブ', 'ﾍﾞ': 'ベ', 'ﾎﾞ': 'ボ',
                'ﾊﾟ': 'パ', 'ﾋﾟ': 'ピ', 'ﾌﾟ': 'プ', 'ﾍﾟ': 'ペ', 'ﾎﾟ': 'ポ',
                'ｳﾞ': 'ヴ', 'ﾜﾞ': 'ヷ', 'ｦﾞ': 'ヺ',
                'ｱ': 'ア', 'ｲ': 'イ', 'ｳ': 'ウ', 'ｴ': 'エ', 'ｵ': 'オ',
                'ｶ': 'カ', 'ｷ': 'キ', 'ｸ': 'ク', 'ｹ': 'ケ', 'ｺ': 'コ',
                'ｻ': 'サ', 'ｼ': 'シ', 'ｽ': 'ス', 'ｾ': 'セ', 'ｿ': 'ソ',
                'ﾀ': 'タ', 'ﾁ': 'チ', 'ﾂ': 'ツ', 'ﾃ': 'テ', 'ﾄ': 'ト',
                'ﾅ': 'ナ', 'ﾆ': 'ニ', 'ﾇ': 'ヌ', 'ﾈ': 'ネ', 'ﾉ': 'ノ',
                'ﾊ': 'ハ', 'ﾋ': 'ヒ', 'ﾌ': 'フ', 'ﾍ': 'ヘ', 'ﾎ': 'ホ',
                'ﾏ': 'マ', 'ﾐ': 'ミ', 'ﾑ': 'ム', 'ﾒ': 'メ', 'ﾓ': 'モ',
                'ﾔ': 'ヤ', 'ﾕ': 'ユ', 'ﾖ': 'ヨ',
                'ﾗ': 'ラ', 'ﾘ': 'リ', 'ﾙ': 'ル', 'ﾚ': 'レ', 'ﾛ': 'ロ',
                'ﾜ': 'ワ', 'ｦ': 'ヲ', 'ﾝ': 'ン',
                'ｧ': 'ァ', 'ｨ': 'ィ', 'ｩ': 'ゥ', 'ｪ': 'ェ', 'ｫ': 'ォ',
                'ｯ': 'ッ', 'ｬ': 'ャ', 'ｭ': 'ュ', 'ｮ': 'ョ',
                '｡': '。', '､': '、', 'ｰ': 'ー', '｢': '「', '｣': '」', '･': '・'
            };

            var reg = new RegExp('(' + Object.keys(kanaMap).join('|') + ')', 'g');
            return str
                .replace(reg, function (match) {
                    return kanaMap[match];
                })
                .replace(/ﾞ/g, '゛')
                .replace(/ﾟ/g, '゜');
        },
        kanaToHira(str) {
            return str.replace(/[\u30a1-\u30f6]/g, function (match) {
                var chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        },
        hiraToKana(str) {
            return str.replace(/[\u3041-\u3096]/g, function (match) {
                var chr = match.charCodeAt(0) + 0x60;
                return String.fromCharCode(chr);
            });
        },
        toHankaku(str) {
            return TranslateUtil.zenkana2Hankana(
                TranslateUtil.zenkaku2Hankaku(str)
            );
        },
        toZenkaku(str) {
            return TranslateUtil.hankaku2Zenkaku(
                TranslateUtil.hankana2Zenkana(str)
            );
        }
    }
});

Ext.define('Pages.components.Utils', {});